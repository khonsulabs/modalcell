<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module documents the reasoning behind this crate’s safety guarantees."><title>modalcell::safety - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="modalcell" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../modalcell/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../modalcell/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module safety</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">modalcell</a>::<wbr><a class="mod" href="#">safety</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/modalcell/safety.rs.html#1-110">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module documents the reasoning behind this crate’s safety guarantees.</p>
<p>This crate uses <code>UnsafeCell</code> internally, but only has a small amount of
unsafe code. The goal of this crate is to ensure that at compile time, all
Rust borrowing invariants are guaranteed to be upheld. This means that it
should be impossible to gain access to an <code>&amp;mut T</code> while a <code>&amp;T</code> is in
existence.</p>
<p>To prevent this, several design decisions were made about the types in this
crate:</p>
<ul>
<li><a href="../struct.SharedMode.html" title="struct modalcell::SharedMode"><code>SharedMode</code></a> does not implement <code>Clone</code>. This ensures
the compiler’s borrow checking rules on a <code>SharedMode</code> value can be
extended to cells that are associated with this <code>SharedMode</code>.</li>
<li><a href="../struct.SharedMode.html#method.as_exclusive" title="method modalcell::SharedMode::as_exclusive"><code>SharedMode::as_exclusive()</code></a>
exclusively borrows the <code>SharedMode</code> and returns an
<a href="../struct.ExclusiveMode.html" title="struct modalcell::ExclusiveMode"><code>ExclusiveMode&lt;'_&gt;</code></a>. This lifetime causes the
compiler to reject any attempt at using the underlying <code>&amp;SharedMode</code> until
the lifetime is no longer in use.</li>
<li><a href="../struct.ExclusiveCell.html#method.get_mut" title="method modalcell::ExclusiveCell::get_mut"><code>ExclusiveCell::get_mut</code></a> requires an
<a href="../struct.ExclusiveMode.html" title="struct modalcell::ExclusiveMode"><code>ExclusiveMode</code></a> to return access to its value. The
returned <a href="../struct.RefMut.html" title="struct modalcell::RefMut"><code>RefMut</code></a> merges the cell’s lifetime and the
mode’s lifetime, ensuring the Rust compiler will error on invalid usage.</li>
<li><a href="../struct.SharedCell.html#method.get" title="method modalcell::SharedCell::get"><code>SharedCell::get</code></a> requires a
<a href="../struct.SharedMode.html" title="struct modalcell::SharedMode"><code>&amp;SharedMode</code></a>.
<a href="../struct.ExclusiveMode.html" title="struct modalcell::ExclusiveMode"><code>ExclusiveMode</code></a> does not provide a way to access
the <code>SharedMode</code> it is wrapping. These two guarantees allow the compiler
to ensure that only either <a href="../struct.SharedCell.html#method.get" title="method modalcell::SharedCell::get"><code>SharedCell::get</code></a> or
<a href="../struct.ExclusiveCell.html#method.get_mut" title="method modalcell::ExclusiveCell::get_mut"><code>ExclusiveCell::get_mut</code></a> can be accessed
at any given line of code.</li>
<li><a href="../struct.SharedCell.html" title="struct modalcell::SharedCell"><code>SharedCell</code></a> implements <code>Clone</code>, but
<a href="../struct.ExclusiveCell.html" title="struct modalcell::ExclusiveCell"><code>ExclusiveCell</code></a> does not. This matches Rust’s
rules that only one exclusive reference should be able to exist, while it
is valid to have as many shared references as desired.</li>
</ul>
<h3 id="examples-demonstrating-compile-time-checking"><a href="#examples-demonstrating-compile-time-checking">Examples demonstrating compile-time checking</a></h3><h4 id="unable-to-use-sharedmode-while-exclusivemode-exists"><a href="#unable-to-use-sharedmode-while-exclusivemode-exists">Unable to use <code>SharedMode</code> while <code>ExclusiveMode</code> exists</a></h4><h5 id="incorrect-usage"><a href="#incorrect-usage">Incorrect usage:</a></h5>
<p><code>error[E0502]: cannot borrow </code>shared<code> as immutable because it is also borrowed as mutable</code></p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::SharedMode;
<span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell = shared.new_cell(<span class="number">1</span>);
<span class="kw">let </span>shared_cell = exclusive_cell.as_shared();
<span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="comment">//              --------------------- mutable borrow occurs here
</span><span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">2</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>shared_cell.get(<span class="kw-2">&amp;</span>shared), <span class="number">2</span>);
<span class="comment">//                          ^^^^^^^ immutable borrow occurs here

</span><span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">3</span>;
<span class="comment">//                      --------- mutable borrow later used here</span></code></pre></div>
<h5 id="correct-usage"><a href="#correct-usage">Correct usage:</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::SharedMode;

<span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell = shared.new_cell(<span class="number">1</span>);
<span class="kw">let </span>shared_cell = exclusive_cell.as_shared();
<span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">2</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>shared_cell.get(<span class="kw-2">&amp;</span>shared), <span class="number">2</span>);

<span class="comment">// By creating a new exclusive session, the compiler ends the
// previous `exclusive` borrow at its last usage.
</span><span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">3</span>;</code></pre></div>
<h4 id="unable-to-get-an-exclusivemode-while-a-sharedmode-is-borrowed"><a href="#unable-to-get-an-exclusivemode-while-a-sharedmode-is-borrowed">Unable to get an <code>ExclusiveMode</code> while a <code>SharedMode</code> is borrowed.</a></h4><h5 id="incorrect-usage-1"><a href="#incorrect-usage-1">Incorrect usage:</a></h5>
<p><code>error[E0502]: cannot borrow </code>shared<code> as mutable because it is also borrowed as immutable</code></p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::SharedMode;
<span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell = shared.new_cell(<span class="number">1</span>);
<span class="kw">let </span>shared_cell = exclusive_cell.as_shared();
<span class="kw">let </span>cell_contents = shared_cell.get(<span class="kw-2">&amp;</span>shared);
<span class="comment">//                                  ------- immutable borrow occurs here
</span><span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="comment">//              ^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
</span><span class="macro">assert_eq!</span>(<span class="kw-2">*</span>cell_contents, <span class="number">1</span>);
<span class="comment">//------------------------------ immutable borrow later used here

</span><span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">3</span>;</code></pre></div>
<h5 id="correct-usage-1"><a href="#correct-usage-1">Correct usage:</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::SharedMode;
<span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell = shared.new_cell(<span class="number">1</span>);
<span class="kw">let </span>shared_cell = exclusive_cell.as_shared();
<span class="kw">let </span>cell_contents = shared_cell.get(<span class="kw-2">&amp;</span>shared);
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>cell_contents, <span class="number">1</span>);

<span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">3</span>;</code></pre></div>
</div></details></section></div></main></body></html>