<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Documentation and doctests attempting to prove the safety of this crate. This code uses `UnsafeCell` internally, but only has a small amount of unsafe code. The goal of this crate is to ensure that at compile time, all Rust borrowing invariants are guaranteed to be upheld. This means that it should be impossible to gain access to a `&amp;T` while an `&amp;mut T` is in existence."><title>modalcell::safety - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="modalcell" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../modalcell/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../modalcell/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module safety</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">modalcell</a>::<wbr><a class="mod" href="#">safety</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/modalcell/lib.rs.html#319">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Documentation and doctests attempting to prove the safety of this crate.
This code uses <code>UnsafeCell</code> internally, but only has a small amount of
unsafe code. The goal of this crate is to ensure that at compile time,
all Rust borrowing invariants are guaranteed to be upheld. This means
that it should be impossible to gain access to a <code>&amp;T</code> while an <code>&amp;mut T</code>
is in existence.</p>
<p>To prevent this, several design decisions were made about the types in
this crate:</p>
<ul>
<li><code>SharedMode</code> does not implement <code>Clone</code>. This ensures the compiler’s
borrow checking rules on a <code>SharedMode</code> value can be extended to cells
that are associated with this <code>SharedMode</code>.</li>
<li><code>SharedMode::as_exclusive()</code> exclusively borrows the <code>SharedMode</code> and
returns an <code>ExclusiveMode&lt;'_&gt;</code>. This lifetime causes the compiler to
reject any attempt at using the underlying <code>&amp;SharedMode</code> until the
lifetime is no longer in use.</li>
<li><code>ExclusiveCell::get_mut</code> requires an <code>ExclusiveMode</code> to return access
to its value. The returned <code>RefMut</code> encompasses both the cell’s
lifetime and the mode’s lifetime, causing compilation errors to arise
from invalid usage.</li>
<li><code>SharedCell::get</code> requires a <code>&amp;SharedMode</code>. <code>ExclusiveMode</code> does not
provide a way to access the <code>SharedMode</code> it is wrapping, ensuring that
the compiler enforces that only either <code>SharedCell::get</code> or
<code>ExclusiveCell::get_mut</code> can be accessed at any given line of code.</li>
<li><code>SharedCell</code> implements <code>Clone</code>, but <code>ExclusiveCell</code> does not. This
upholds Rust’s guarantees that only one exclusive reference should be
able to exist, while it is valid to have as many shared references as
desired.</li>
</ul>
<h3 id="unable-to-use-sharedmode-while-exclusivemode-exists"><a href="#unable-to-use-sharedmode-while-exclusivemode-exists">Unable to use <code>SharedMode</code> while <code>ExclusiveMode</code> exists</a></h3>
<p>Incorrect usage:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::SharedMode;
<span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell = shared.new_cell(<span class="number">1</span>);
<span class="kw">let </span>shared_cell = exclusive_cell.as_shared();
<span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">2</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>shared_cell.get(<span class="kw-2">&amp;</span>shared), <span class="number">2</span>);

<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">3</span>;</code></pre></div>
<p>Correct usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::SharedMode;

<span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell = shared.new_cell(<span class="number">1</span>);
<span class="kw">let </span>shared_cell = exclusive_cell.as_shared();
<span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">2</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>shared_cell.get(<span class="kw-2">&amp;</span>shared), <span class="number">2</span>);

<span class="comment">// By creating a new exclusive session, the compiler ends the
// previous `exclusive` borrow at its last usage.
</span><span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">3</span>;</code></pre></div>
<h3 id="unable-to-get-an-exclusivemode-while-a-sharedmode-is-borrowed"><a href="#unable-to-get-an-exclusivemode-while-a-sharedmode-is-borrowed">Unable to get an <code>ExclusiveMode</code> while a <code>SharedMode</code> is borrowed.</a></h3>
<p>Incorrect usage:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::SharedMode;
<span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell = shared.new_cell(<span class="number">1</span>);
<span class="kw">let </span>shared_cell = exclusive_cell.as_shared();
<span class="kw">let </span>cell_contents = shared_cell.get(<span class="kw-2">&amp;</span>shared);
<span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>cell_contents, <span class="number">1</span>);

<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">3</span>;</code></pre></div>
<p>Correct usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::SharedMode;
<span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell = shared.new_cell(<span class="number">1</span>);
<span class="kw">let </span>shared_cell = exclusive_cell.as_shared();
<span class="kw">let </span>cell_contents = shared_cell.get(<span class="kw-2">&amp;</span>shared);
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>cell_contents, <span class="number">1</span>);

<span class="kw">let </span>exclusive = shared.as_exclusive();
<span class="kw-2">*</span>exclusive_cell.get_mut(exclusive) = <span class="number">3</span>;</code></pre></div>
</div></details></section></div></main></body></html>