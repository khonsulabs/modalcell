<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="ModalCell"><title>modalcell - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="modalcell" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../modalcell/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../modalcell/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate modalcell</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">modalcell</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/modalcell/lib.rs.html#1-404">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="modalcell"><a href="#modalcell">ModalCell</a></h2>
<p><a href="https://crates.io/crates/modalcell"><img src="https://img.shields.io/crates/v/modalcell.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/modalcell/actions?query=workflow:Tests"><img src="https://img.shields.io/github/actions/workflow/status/khonsulabs/modalcell/rust.yml?branch=main" alt="Live Build Status" /></a>
<a href="https://khonsulabs.github.io/modalcell/main/modalcell/"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation for main branch" /></a></p>
<p>ModalCell provides an approach for using Rust’s borrow checker to enforce access
to a value via an associated mode.</p>
<p>Consider this example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>modalcell::{ExclusiveCell, ExclusiveMode, RefMut, SharedCell, SharedMode};

<span class="comment">// Create our shared mode.
</span><span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new();
<span class="comment">// Obtain exclusvie access to the mode.
</span><span class="kw">let </span>exclusive: ExclusiveMode&lt;<span class="lifetime">&#39;_</span>, <span class="kw">_</span>&gt; = shared.as_exclusive();
<span class="comment">// Create a new cell with the initial value of `1`. This cell can be
// accessed `mut`-ably using an `ExclusiveMode`.
</span><span class="kw">let </span><span class="kw-2">mut </span>exclusive_cell: ExclusiveCell&lt;usize, <span class="kw">_</span>&gt; = exclusive.new_cell(<span class="number">1</span>);
<span class="comment">// Obtain a SharedCell, which can be converted to an `&amp;T` using a
// `SharedMode`.
</span><span class="kw">let </span>shared_cell: SharedCell&lt;usize, <span class="kw">_</span>&gt; = exclusive_cell.as_shared();

<span class="comment">// The Rust compiler now guarantees safe access to the data.
// shared_cell.get(&amp;shared); // Because `exclusive` borrowed from
//                           // `shared`, this is a compilation error.

</span><span class="kw">let </span>cell_contents: <span class="kw-2">&amp;</span>usize = shared_cell.get(<span class="kw-2">&amp;</span>shared);
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>cell_contents, <span class="number">1</span>);

<span class="comment">// To change the value, we must obtain exclusive access again.
</span><span class="kw">let </span>exclusive: ExclusiveMode&lt;<span class="lifetime">&#39;_</span>, <span class="kw">_</span>&gt; = shared.as_exclusive();

<span class="comment">// `&amp;T` references prevent entering exclusive mode. This can be tested by
// uncommenting the following line:
// assert_eq!(*cell_contents, 1);

// Each RefMut tracks the lifetime of the &amp;mut ExclusiveCell&lt;T&gt; as well as
// the lifetime of the `ExclusiveMode`. This ensures that no `&amp;mut T` can be
// created without exclusive access to `shared`.
</span><span class="kw">let </span><span class="kw-2">mut </span>cell_contents: RefMut&lt;<span class="lifetime">&#39;_</span>, <span class="lifetime">&#39;_</span>, usize, <span class="kw">_</span>&gt; = exclusive_cell.get_mut(exclusive);
<span class="kw-2">*</span>cell_contents = <span class="number">2</span>;

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>shared_cell.get(<span class="kw-2">&amp;</span>shared), <span class="number">2</span>);

<span class="comment">// Accessing `shared_cell` can only be done safely if `cell_contents` isn&#39;t
// used again. Uncommenting this line will produce a compiler error.
// *cell_contents = 3;</span></code></pre></div>
<p>The approach taken by this crate gives similar properties to an
<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>, except that with an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> the contents must be
accessed through <code>std::cell::Ref</code>/<code>std::cell::RefMut</code>. This crate allows direct
access to shared references without an intermediate type. With this type, the
Rust compiler enforces correctness, while <code>RefCell</code> requires runtime checks.</p>
<p>This crate still performs one check at runtime: is the mode being passed the
same one that was used to create the cell. Because this is a logic bug, passing
an incorrect mode will result in a panic.</p>
<p>This crate also provides an implementation that allows using this mode of data
access in multi-threaded code:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::mpsc::{Receiver, SyncSender};

<span class="kw">use </span>modalcell::{ExclusiveCell, SharedMode, ThreadSafe};

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>shared = SharedMode::new_threadsafe();
    <span class="kw">let </span>cell = shared.new_cell(<span class="number">0</span>);
    <span class="kw">let </span>shared_cell = cell.as_shared();

    <span class="kw">let </span>(counting_sender, counting_receiver) = std::sync::mpsc::sync_channel(<span class="number">1</span>);
    <span class="kw">let </span>(printing_sender, printing_receiver) = std::sync::mpsc::sync_channel(<span class="number">1</span>);

    <span class="comment">// Spawn a thread that updates the value.
    </span>std::thread::spawn(|| counting_thread(cell, counting_receiver, printing_sender));

    <span class="kw">loop </span>{
        <span class="comment">// Send the mode to the thread, allowing it to gain mutable access.
        </span>counting_sender.send(shared).unwrap();
        <span class="comment">// Wait for mode to be returned to us.
        </span>shared = printing_receiver.recv().unwrap();
        <span class="comment">// Use it to gain access a reference of the value.
        </span><span class="kw">let </span>value: <span class="kw-2">&amp;</span>usize = shared_cell.get(<span class="kw-2">&amp;</span>shared);
        <span class="macro">println!</span>(<span class="string">&quot;New Count: {value}&quot;</span>);
        <span class="comment">// Stop after 10.
        </span><span class="kw">if </span><span class="kw-2">*</span>value == <span class="number">10 </span>{
            <span class="kw">break</span>;
        }
    }
}

<span class="kw">fn </span>counting_thread(
    <span class="kw-2">mut </span>cell: ExclusiveCell&lt;usize, ThreadSafe&gt;,
    receiver: Receiver&lt;SharedMode&lt;ThreadSafe&gt;&gt;,
    sender: SyncSender&lt;SharedMode&lt;ThreadSafe&gt;&gt;,
) {
    <span class="kw">while let </span><span class="prelude-val">Ok</span>(<span class="kw-2">mut </span>shared) = receiver.recv() {
        <span class="comment">// Enter exclusive mode. This is a borrow-checker only operation and has
        // no runtime overhead.
        </span><span class="kw">let </span>exclusive = shared.as_exclusive();
        <span class="comment">// Gain access to the cell&#39;s contents using our exclusive marker.
        </span><span class="kw">let </span><span class="kw-2">mut </span>contents = cell.get_mut(exclusive);
        <span class="comment">// Update the value through DerefMut.
        </span><span class="kw-2">*</span>contents += <span class="number">1</span>;
        <span class="comment">// Return the `SharedMode` back to the other thread.
        </span>sender.send(shared).unwrap();

        <span class="comment">// Attempting to use `exclusive` now will result in a compiler error.
        // let _error = cell.get_mut(exclusive);
        // let _error = *contents;
    </span>}
}</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="safety/index.html" title="mod modalcell::safety">safety</a></div><div class="desc docblock-short">Documentation and doctests attempting to prove the safety of this crate.
This code uses <code>UnsafeCell</code> internally, but only has a small amount of
unsafe code. The goal of this crate is to ensure that at compile time,
all Rust borrowing invariants are guaranteed to be upheld. This means
that it should be impossible to gain access to an <code>&amp;T</code> while an <code>&amp;mut T</code>
is in existence.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ExclusiveCell.html" title="struct modalcell::ExclusiveCell">ExclusiveCell</a></div><div class="desc docblock-short">A wrapper type that guarantees memory safety by only allowing access when
its associated <a href="struct.ExclusiveMode.html" title="struct modalcell::ExclusiveMode"><code>ExclusiveMode</code></a> tag is provided.</div></li><li><div class="item-name"><a class="struct" href="struct.ExclusiveMode.html" title="struct modalcell::ExclusiveMode">ExclusiveMode</a></div><div class="desc docblock-short">A tag that allows exclusive access to the underlying <a href="struct.SharedMode.html" title="struct modalcell::SharedMode"><code>SharedMode</code></a>’s
associated <a href="struct.ExclusiveCell.html" title="struct modalcell::ExclusiveCell"><code>ExclusiveCell</code></a>s.</div></li><li><div class="item-name"><a class="struct" href="struct.RefMut.html" title="struct modalcell::RefMut">RefMut</a></div><div class="desc docblock-short">A wrapper to an exclusive reference to an <a href="struct.ExclusiveCell.html" title="struct modalcell::ExclusiveCell"><code>ExclusiveCell</code></a>’s contents.</div></li><li><div class="item-name"><a class="struct" href="struct.SharedCell.html" title="struct modalcell::SharedCell">SharedCell</a></div><div class="desc docblock-short">A read-only reference to a <a href="struct.ExclusiveCell.html" title="struct modalcell::ExclusiveCell"><code>ExclusiveCell</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.SharedMode.html" title="struct modalcell::SharedMode">SharedMode</a></div><div class="desc docblock-short">A tag that allows read-only access to its associated <a href="struct.ExclusiveCell.html" title="struct modalcell::ExclusiveCell"><code>ExclusiveCell</code></a>s.</div></li><li><div class="item-name"><a class="struct" href="struct.SingleThreaded.html" title="struct modalcell::SingleThreaded">SingleThreaded</a></div><div class="desc docblock-short">A <a href="trait.Mode.html" title="trait modalcell::Mode"><code>Mode</code></a> that uses <a href="https://doc.rust-lang.org/1.72.1/alloc/rc/struct.Rc.html" title="struct alloc::rc::Rc"><code>Rc</code></a>, which is optimized for single-threaded use
cases.</div></li><li><div class="item-name"><a class="struct" href="struct.ThreadSafe.html" title="struct modalcell::ThreadSafe">ThreadSafe</a></div><div class="desc docblock-short">A <a href="trait.Mode.html" title="trait modalcell::Mode"><code>Mode</code></a> that uses <a href="https://doc.rust-lang.org/1.72.1/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc"><code>Arc</code></a> for thread-safety.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Mode.html" title="trait modalcell::Mode">Mode</a></div><div class="desc docblock-short">A trait controlling how <a href="struct.SharedMode.html" title="struct modalcell::SharedMode"><code>SharedMode</code></a> and all associated types store
reference-counted values.</div></li></ul></section></div></main></body></html>